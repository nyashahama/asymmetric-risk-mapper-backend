// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const attachStripeCustomer = `-- name: AttachStripeCustomer :one
UPDATE sessions
SET stripe_customer_id    = $2,
    stripe_payment_intent = $3,
    email                 = $4
WHERE id = $1
RETURNING id, anon_token, email, biz_name, industry, stage, stripe_customer_id, stripe_payment_intent, payment_status, paid_at, utm_source, utm_medium, utm_campaign, referrer, ip_hash, user_agent, created_at, updated_at
`

type AttachStripeCustomerParams struct {
	ID                  uuid.UUID      `db:"id" json:"id"`
	StripeCustomerID    sql.NullString `db:"stripe_customer_id" json:"stripe_customer_id"`
	StripePaymentIntent sql.NullString `db:"stripe_payment_intent" json:"stripe_payment_intent"`
	Email               sql.NullString `db:"email" json:"email"`
}

func (q *Queries) AttachStripeCustomer(ctx context.Context, arg AttachStripeCustomerParams) (Session, error) {
	row := q.queryRow(ctx, q.attachStripeCustomerStmt, attachStripeCustomer,
		arg.ID,
		arg.StripeCustomerID,
		arg.StripePaymentIntent,
		arg.Email,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AnonToken,
		&i.Email,
		&i.BizName,
		&i.Industry,
		&i.Stage,
		&i.StripeCustomerID,
		&i.StripePaymentIntent,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.Referrer,
		&i.IpHash,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countAnsweredBySession = `-- name: CountAnsweredBySession :one
SELECT COUNT(*) FROM answers WHERE session_id = $1 AND answer_text != ''
`

func (q *Queries) CountAnsweredBySession(ctx context.Context, sessionID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countAnsweredBySessionStmt, countAnsweredBySession, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReport = `-- name: CreateReport :one

INSERT INTO reports (session_id)
VALUES ($1)
RETURNING id, session_id, status, error_message, overall_score, critical_count, risks_json, executive_summary, top_priority_html, access_token, generated_at, created_at, updated_at
`

// ---------------------------------------------------------------------------
// REPORTS
// ---------------------------------------------------------------------------
func (q *Queries) CreateReport(ctx context.Context, sessionID uuid.UUID) (Report, error) {
	row := q.queryRow(ctx, q.createReportStmt, createReport, sessionID)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Status,
		&i.ErrorMessage,
		&i.OverallScore,
		&i.CriticalCount,
		&i.RisksJson,
		&i.ExecutiveSummary,
		&i.TopPriorityHtml,
		&i.AccessToken,
		&i.GeneratedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one


INSERT INTO sessions (anon_token, utm_source, utm_medium, utm_campaign, referrer, ip_hash, user_agent)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, anon_token, email, biz_name, industry, stage, stripe_customer_id, stripe_payment_intent, payment_status, paid_at, utm_source, utm_medium, utm_campaign, referrer, ip_hash, user_agent, created_at, updated_at
`

type CreateSessionParams struct {
	AnonToken   string         `db:"anon_token" json:"anon_token"`
	UtmSource   sql.NullString `db:"utm_source" json:"utm_source"`
	UtmMedium   sql.NullString `db:"utm_medium" json:"utm_medium"`
	UtmCampaign sql.NullString `db:"utm_campaign" json:"utm_campaign"`
	Referrer    sql.NullString `db:"referrer" json:"referrer"`
	IpHash      sql.NullString `db:"ip_hash" json:"ip_hash"`
	UserAgent   sql.NullString `db:"user_agent" json:"user_agent"`
}

// =============================================================================
// sqlc QUERIES â€” Asymmetric Risk Mapper
// Run: sqlc generate  (sqlc.yaml points here)
// =============================================================================
// ---------------------------------------------------------------------------
// SESSIONS
// ---------------------------------------------------------------------------
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.queryRow(ctx, q.createSessionStmt, createSession,
		arg.AnonToken,
		arg.UtmSource,
		arg.UtmMedium,
		arg.UtmCampaign,
		arg.Referrer,
		arg.IpHash,
		arg.UserAgent,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AnonToken,
		&i.Email,
		&i.BizName,
		&i.Industry,
		&i.Stage,
		&i.StripeCustomerID,
		&i.StripePaymentIntent,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.Referrer,
		&i.IpHash,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const finalizeReport = `-- name: FinalizeReport :one
UPDATE reports
SET status          = 'ready',
    overall_score   = $2,
    critical_count  = $3,
    risks_json      = $4,
    executive_summary = $5,
    top_priority_html = $6,
    generated_at    = now()
WHERE id = $1
RETURNING id, session_id, status, error_message, overall_score, critical_count, risks_json, executive_summary, top_priority_html, access_token, generated_at, created_at, updated_at
`

type FinalizeReportParams struct {
	ID               uuid.UUID             `db:"id" json:"id"`
	OverallScore     sql.NullInt16         `db:"overall_score" json:"overall_score"`
	CriticalCount    sql.NullInt16         `db:"critical_count" json:"critical_count"`
	RisksJson        pqtype.NullRawMessage `db:"risks_json" json:"risks_json"`
	ExecutiveSummary sql.NullString        `db:"executive_summary" json:"executive_summary"`
	TopPriorityHtml  sql.NullString        `db:"top_priority_html" json:"top_priority_html"`
}

func (q *Queries) FinalizeReport(ctx context.Context, arg FinalizeReportParams) (Report, error) {
	row := q.queryRow(ctx, q.finalizeReportStmt, finalizeReport,
		arg.ID,
		arg.OverallScore,
		arg.CriticalCount,
		arg.RisksJson,
		arg.ExecutiveSummary,
		arg.TopPriorityHtml,
	)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Status,
		&i.ErrorMessage,
		&i.OverallScore,
		&i.CriticalCount,
		&i.RisksJson,
		&i.ExecutiveSummary,
		&i.TopPriorityHtml,
		&i.AccessToken,
		&i.GeneratedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllQuestionDefinitions = `-- name: GetAllQuestionDefinitions :many

SELECT id, question_version, section_id, section_title, display_order, text, subtext, type, opts, placeholder, required, risk_name, risk_desc, hedge, scoring_config, is_scoring, created_at FROM question_definitions
ORDER BY section_id, display_order
`

// ---------------------------------------------------------------------------
// QUESTION DEFINITIONS
// ---------------------------------------------------------------------------
func (q *Queries) GetAllQuestionDefinitions(ctx context.Context) ([]QuestionDefinition, error) {
	rows, err := q.query(ctx, q.getAllQuestionDefinitionsStmt, getAllQuestionDefinitions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuestionDefinition{}
	for rows.Next() {
		var i QuestionDefinition
		if err := rows.Scan(
			&i.ID,
			&i.QuestionVersion,
			&i.SectionID,
			&i.SectionTitle,
			&i.DisplayOrder,
			&i.Text,
			&i.Subtext,
			&i.Type,
			pq.Array(&i.Opts),
			&i.Placeholder,
			&i.Required,
			&i.RiskName,
			&i.RiskDesc,
			&i.Hedge,
			&i.ScoringConfig,
			&i.IsScoring,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnswersBySession = `-- name: GetAnswersBySession :many
SELECT a.id, a.session_id, a.question_id, a.answer_text, a.client_p, a.client_i, a.answered_at, a.updated_at, qd.section_id, qd.risk_name, qd.risk_desc, qd.hedge, qd.scoring_config, qd.is_scoring
FROM answers a
JOIN question_definitions qd ON qd.id = a.question_id
WHERE a.session_id = $1
ORDER BY qd.display_order
`

type GetAnswersBySessionRow struct {
	ID            uuid.UUID       `db:"id" json:"id"`
	SessionID     uuid.UUID       `db:"session_id" json:"session_id"`
	QuestionID    string          `db:"question_id" json:"question_id"`
	AnswerText    string          `db:"answer_text" json:"answer_text"`
	ClientP       sql.NullInt16   `db:"client_p" json:"client_p"`
	ClientI       sql.NullInt16   `db:"client_i" json:"client_i"`
	AnsweredAt    time.Time       `db:"answered_at" json:"answered_at"`
	UpdatedAt     time.Time       `db:"updated_at" json:"updated_at"`
	SectionID     SectionID       `db:"section_id" json:"section_id"`
	RiskName      string          `db:"risk_name" json:"risk_name"`
	RiskDesc      string          `db:"risk_desc" json:"risk_desc"`
	Hedge         string          `db:"hedge" json:"hedge"`
	ScoringConfig json.RawMessage `db:"scoring_config" json:"scoring_config"`
	IsScoring     bool            `db:"is_scoring" json:"is_scoring"`
}

func (q *Queries) GetAnswersBySession(ctx context.Context, sessionID uuid.UUID) ([]GetAnswersBySessionRow, error) {
	rows, err := q.query(ctx, q.getAnswersBySessionStmt, getAnswersBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAnswersBySessionRow{}
	for rows.Next() {
		var i GetAnswersBySessionRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.QuestionID,
			&i.AnswerText,
			&i.ClientP,
			&i.ClientI,
			&i.AnsweredAt,
			&i.UpdatedAt,
			&i.SectionID,
			&i.RiskName,
			&i.RiskDesc,
			&i.Hedge,
			&i.ScoringConfig,
			&i.IsScoring,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompletionFunnelStats = `-- name: GetCompletionFunnelStats :one
SELECT
    COUNT(*)                                                        AS total_sessions,
    COUNT(*) FILTER (WHERE (SELECT COUNT(*) FROM answers a WHERE a.session_id = s.id) > 0) AS started,
    COUNT(*) FILTER (WHERE payment_status = 'paid')                AS paid,
    COUNT(*) FILTER (WHERE payment_status = 'paid' AND EXISTS (
        SELECT 1 FROM reports r WHERE r.session_id = s.id AND r.status = 'ready'
    ))                                                              AS report_delivered
FROM sessions s
`

type GetCompletionFunnelStatsRow struct {
	TotalSessions   int64 `db:"total_sessions" json:"total_sessions"`
	Started         int64 `db:"started" json:"started"`
	Paid            int64 `db:"paid" json:"paid"`
	ReportDelivered int64 `db:"report_delivered" json:"report_delivered"`
}

func (q *Queries) GetCompletionFunnelStats(ctx context.Context) (GetCompletionFunnelStatsRow, error) {
	row := q.queryRow(ctx, q.getCompletionFunnelStatsStmt, getCompletionFunnelStats)
	var i GetCompletionFunnelStatsRow
	err := row.Scan(
		&i.TotalSessions,
		&i.Started,
		&i.Paid,
		&i.ReportDelivered,
	)
	return i, err
}

const getDailyRevenue = `-- name: GetDailyRevenue :many
SELECT
    DATE(paid_at)       AS day,
    COUNT(*)            AS sales,
    COUNT(*) * 59       AS revenue_usd   -- $59 fixed price
FROM sessions
WHERE payment_status = 'paid'
  AND paid_at >= now() - INTERVAL '30 days'
GROUP BY DATE(paid_at)
ORDER BY day DESC
`

type GetDailyRevenueRow struct {
	Day        time.Time `db:"day" json:"day"`
	Sales      int64     `db:"sales" json:"sales"`
	RevenueUsd int32     `db:"revenue_usd" json:"revenue_usd"`
}

func (q *Queries) GetDailyRevenue(ctx context.Context) ([]GetDailyRevenueRow, error) {
	rows, err := q.query(ctx, q.getDailyRevenueStmt, getDailyRevenue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyRevenueRow{}
	for rows.Next() {
		var i GetDailyRevenueRow
		if err := rows.Scan(&i.Day, &i.Sales, &i.RevenueUsd); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionByID = `-- name: GetQuestionByID :one
SELECT id, question_version, section_id, section_title, display_order, text, subtext, type, opts, placeholder, required, risk_name, risk_desc, hedge, scoring_config, is_scoring, created_at FROM question_definitions WHERE id = $1 LIMIT 1
`

func (q *Queries) GetQuestionByID(ctx context.Context, id string) (QuestionDefinition, error) {
	row := q.queryRow(ctx, q.getQuestionByIDStmt, getQuestionByID, id)
	var i QuestionDefinition
	err := row.Scan(
		&i.ID,
		&i.QuestionVersion,
		&i.SectionID,
		&i.SectionTitle,
		&i.DisplayOrder,
		&i.Text,
		&i.Subtext,
		&i.Type,
		pq.Array(&i.Opts),
		&i.Placeholder,
		&i.Required,
		&i.RiskName,
		&i.RiskDesc,
		&i.Hedge,
		&i.ScoringConfig,
		&i.IsScoring,
		&i.CreatedAt,
	)
	return i, err
}

const getReportByAccessToken = `-- name: GetReportByAccessToken :one
SELECT r.id, r.session_id, r.status, r.error_message, r.overall_score, r.critical_count, r.risks_json, r.executive_summary, r.top_priority_html, r.access_token, r.generated_at, r.created_at, r.updated_at, s.biz_name, s.industry, s.stage, s.email
FROM reports r
JOIN sessions s ON s.id = r.session_id
WHERE r.access_token = $1
LIMIT 1
`

type GetReportByAccessTokenRow struct {
	ID               uuid.UUID             `db:"id" json:"id"`
	SessionID        uuid.UUID             `db:"session_id" json:"session_id"`
	Status           ReportStatus          `db:"status" json:"status"`
	ErrorMessage     sql.NullString        `db:"error_message" json:"error_message"`
	OverallScore     sql.NullInt16         `db:"overall_score" json:"overall_score"`
	CriticalCount    sql.NullInt16         `db:"critical_count" json:"critical_count"`
	RisksJson        pqtype.NullRawMessage `db:"risks_json" json:"risks_json"`
	ExecutiveSummary sql.NullString        `db:"executive_summary" json:"executive_summary"`
	TopPriorityHtml  sql.NullString        `db:"top_priority_html" json:"top_priority_html"`
	AccessToken      string                `db:"access_token" json:"access_token"`
	GeneratedAt      sql.NullTime          `db:"generated_at" json:"generated_at"`
	CreatedAt        time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time             `db:"updated_at" json:"updated_at"`
	BizName          sql.NullString        `db:"biz_name" json:"biz_name"`
	Industry         sql.NullString        `db:"industry" json:"industry"`
	Stage            sql.NullString        `db:"stage" json:"stage"`
	Email            sql.NullString        `db:"email" json:"email"`
}

func (q *Queries) GetReportByAccessToken(ctx context.Context, accessToken string) (GetReportByAccessTokenRow, error) {
	row := q.queryRow(ctx, q.getReportByAccessTokenStmt, getReportByAccessToken, accessToken)
	var i GetReportByAccessTokenRow
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Status,
		&i.ErrorMessage,
		&i.OverallScore,
		&i.CriticalCount,
		&i.RisksJson,
		&i.ExecutiveSummary,
		&i.TopPriorityHtml,
		&i.AccessToken,
		&i.GeneratedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BizName,
		&i.Industry,
		&i.Stage,
		&i.Email,
	)
	return i, err
}

const getReportByID = `-- name: GetReportByID :one
SELECT id, session_id, status, error_message, overall_score, critical_count, risks_json, executive_summary, top_priority_html, access_token, generated_at, created_at, updated_at FROM reports WHERE id = $1 LIMIT 1
`

func (q *Queries) GetReportByID(ctx context.Context, id uuid.UUID) (Report, error) {
	row := q.queryRow(ctx, q.getReportByIDStmt, getReportByID, id)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Status,
		&i.ErrorMessage,
		&i.OverallScore,
		&i.CriticalCount,
		&i.RisksJson,
		&i.ExecutiveSummary,
		&i.TopPriorityHtml,
		&i.AccessToken,
		&i.GeneratedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReportBySessionID = `-- name: GetReportBySessionID :one
SELECT id, session_id, status, error_message, overall_score, critical_count, risks_json, executive_summary, top_priority_html, access_token, generated_at, created_at, updated_at FROM reports WHERE session_id = $1 LIMIT 1
`

func (q *Queries) GetReportBySessionID(ctx context.Context, sessionID uuid.UUID) (Report, error) {
	row := q.queryRow(ctx, q.getReportBySessionIDStmt, getReportBySessionID, sessionID)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Status,
		&i.ErrorMessage,
		&i.OverallScore,
		&i.CriticalCount,
		&i.RisksJson,
		&i.ExecutiveSummary,
		&i.TopPriorityHtml,
		&i.AccessToken,
		&i.GeneratedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRiskResultsByReport = `-- name: GetRiskResultsByReport :many
SELECT id, report_id, question_id, rank, risk_name, risk_desc, probability, impact, score, tier, hedge, ai_hedge, section FROM risk_results
WHERE report_id = $1
ORDER BY rank
`

func (q *Queries) GetRiskResultsByReport(ctx context.Context, reportID uuid.UUID) ([]RiskResult, error) {
	rows, err := q.query(ctx, q.getRiskResultsByReportStmt, getRiskResultsByReport, reportID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RiskResult{}
	for rows.Next() {
		var i RiskResult
		if err := rows.Scan(
			&i.ID,
			&i.ReportID,
			&i.QuestionID,
			&i.Rank,
			&i.RiskName,
			&i.RiskDesc,
			&i.Probability,
			&i.Impact,
			&i.Score,
			&i.Tier,
			&i.Hedge,
			&i.AiHedge,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRiskStats = `-- name: GetRiskStats :many

SELECT risk_name, tier, section, occurrences, avg_probability, avg_impact, avg_score FROM public_risk_stats
`

// ---------------------------------------------------------------------------
// ANALYTICS
// ---------------------------------------------------------------------------
func (q *Queries) GetRiskStats(ctx context.Context) ([]PublicRiskStat, error) {
	rows, err := q.query(ctx, q.getRiskStatsStmt, getRiskStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PublicRiskStat{}
	for rows.Next() {
		var i PublicRiskStat
		if err := rows.Scan(
			&i.RiskName,
			&i.Tier,
			&i.Section,
			&i.Occurrences,
			&i.AvgProbability,
			&i.AvgImpact,
			&i.AvgScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScoringQuestions = `-- name: GetScoringQuestions :many
SELECT id, question_version, section_id, section_title, display_order, text, subtext, type, opts, placeholder, required, risk_name, risk_desc, hedge, scoring_config, is_scoring, created_at FROM question_definitions
WHERE is_scoring = TRUE
ORDER BY section_id, display_order
`

func (q *Queries) GetScoringQuestions(ctx context.Context) ([]QuestionDefinition, error) {
	rows, err := q.query(ctx, q.getScoringQuestionsStmt, getScoringQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuestionDefinition{}
	for rows.Next() {
		var i QuestionDefinition
		if err := rows.Scan(
			&i.ID,
			&i.QuestionVersion,
			&i.SectionID,
			&i.SectionTitle,
			&i.DisplayOrder,
			&i.Text,
			&i.Subtext,
			&i.Type,
			pq.Array(&i.Opts),
			&i.Placeholder,
			&i.Required,
			&i.RiskName,
			&i.RiskDesc,
			&i.Hedge,
			&i.ScoringConfig,
			&i.IsScoring,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByAnonToken = `-- name: GetSessionByAnonToken :one
SELECT id, anon_token, email, biz_name, industry, stage, stripe_customer_id, stripe_payment_intent, payment_status, paid_at, utm_source, utm_medium, utm_campaign, referrer, ip_hash, user_agent, created_at, updated_at FROM sessions WHERE anon_token = $1 LIMIT 1
`

func (q *Queries) GetSessionByAnonToken(ctx context.Context, anonToken string) (Session, error) {
	row := q.queryRow(ctx, q.getSessionByAnonTokenStmt, getSessionByAnonToken, anonToken)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AnonToken,
		&i.Email,
		&i.BizName,
		&i.Industry,
		&i.Stage,
		&i.StripeCustomerID,
		&i.StripePaymentIntent,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.Referrer,
		&i.IpHash,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, anon_token, email, biz_name, industry, stage, stripe_customer_id, stripe_payment_intent, payment_status, paid_at, utm_source, utm_medium, utm_campaign, referrer, ip_hash, user_agent, created_at, updated_at FROM sessions WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSessionByID(ctx context.Context, id uuid.UUID) (Session, error) {
	row := q.queryRow(ctx, q.getSessionByIDStmt, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AnonToken,
		&i.Email,
		&i.BizName,
		&i.Industry,
		&i.Stage,
		&i.StripeCustomerID,
		&i.StripePaymentIntent,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.Referrer,
		&i.IpHash,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionByStripePI = `-- name: GetSessionByStripePI :one
SELECT id, anon_token, email, biz_name, industry, stage, stripe_customer_id, stripe_payment_intent, payment_status, paid_at, utm_source, utm_medium, utm_campaign, referrer, ip_hash, user_agent, created_at, updated_at FROM sessions WHERE stripe_payment_intent = $1 LIMIT 1
`

func (q *Queries) GetSessionByStripePI(ctx context.Context, stripePaymentIntent sql.NullString) (Session, error) {
	row := q.queryRow(ctx, q.getSessionByStripePIStmt, getSessionByStripePI, stripePaymentIntent)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AnonToken,
		&i.Email,
		&i.BizName,
		&i.Industry,
		&i.Stage,
		&i.StripeCustomerID,
		&i.StripePaymentIntent,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.Referrer,
		&i.IpHash,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnprocessedStripeEvents = `-- name: GetUnprocessedStripeEvents :many
SELECT stripe_event_id, type, payload, processed, processed_at, error, received_at FROM stripe_events
WHERE processed = FALSE
  AND received_at > now() - INTERVAL '24 hours'
ORDER BY received_at
`

func (q *Queries) GetUnprocessedStripeEvents(ctx context.Context) ([]StripeEvent, error) {
	rows, err := q.query(ctx, q.getUnprocessedStripeEventsStmt, getUnprocessedStripeEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StripeEvent{}
	for rows.Next() {
		var i StripeEvent
		if err := rows.Scan(
			&i.StripeEventID,
			&i.Type,
			&i.Payload,
			&i.Processed,
			&i.ProcessedAt,
			&i.Error,
			&i.ReceivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchAndRedRisks = `-- name: GetWatchAndRedRisks :many
SELECT id, report_id, question_id, rank, risk_name, risk_desc, probability, impact, score, tier, hedge, ai_hedge, section FROM risk_results
WHERE report_id = $1 AND tier IN ('watch', 'red')
ORDER BY score DESC
`

func (q *Queries) GetWatchAndRedRisks(ctx context.Context, reportID uuid.UUID) ([]RiskResult, error) {
	rows, err := q.query(ctx, q.getWatchAndRedRisksStmt, getWatchAndRedRisks, reportID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RiskResult{}
	for rows.Next() {
		var i RiskResult
		if err := rows.Scan(
			&i.ID,
			&i.ReportID,
			&i.QuestionID,
			&i.Rank,
			&i.RiskName,
			&i.RiskDesc,
			&i.Probability,
			&i.Impact,
			&i.Score,
			&i.Tier,
			&i.Hedge,
			&i.AiHedge,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRiskResult = `-- name: InsertRiskResult :one

INSERT INTO risk_results (
    report_id, question_id, rank, risk_name, risk_desc,
    probability, impact, score, tier, hedge, section
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, report_id, question_id, rank, risk_name, risk_desc, probability, impact, score, tier, hedge, ai_hedge, section
`

type InsertRiskResultParams struct {
	ReportID    uuid.UUID `db:"report_id" json:"report_id"`
	QuestionID  string    `db:"question_id" json:"question_id"`
	Rank        int16     `db:"rank" json:"rank"`
	RiskName    string    `db:"risk_name" json:"risk_name"`
	RiskDesc    string    `db:"risk_desc" json:"risk_desc"`
	Probability int16     `db:"probability" json:"probability"`
	Impact      int16     `db:"impact" json:"impact"`
	Score       int16     `db:"score" json:"score"`
	Tier        RiskTier  `db:"tier" json:"tier"`
	Hedge       string    `db:"hedge" json:"hedge"`
	Section     string    `db:"section" json:"section"`
}

// ---------------------------------------------------------------------------
// RISK RESULTS
// ---------------------------------------------------------------------------
func (q *Queries) InsertRiskResult(ctx context.Context, arg InsertRiskResultParams) (RiskResult, error) {
	row := q.queryRow(ctx, q.insertRiskResultStmt, insertRiskResult,
		arg.ReportID,
		arg.QuestionID,
		arg.Rank,
		arg.RiskName,
		arg.RiskDesc,
		arg.Probability,
		arg.Impact,
		arg.Score,
		arg.Tier,
		arg.Hedge,
		arg.Section,
	)
	var i RiskResult
	err := row.Scan(
		&i.ID,
		&i.ReportID,
		&i.QuestionID,
		&i.Rank,
		&i.RiskName,
		&i.RiskDesc,
		&i.Probability,
		&i.Impact,
		&i.Score,
		&i.Tier,
		&i.Hedge,
		&i.AiHedge,
		&i.Section,
	)
	return i, err
}

const listPendingReports = `-- name: ListPendingReports :many
SELECT id, session_id, status, error_message, overall_score, critical_count, risks_json, executive_summary, top_priority_html, access_token, generated_at, created_at, updated_at FROM reports
WHERE status IN ('draft', 'processing')
  AND created_at > now() - INTERVAL '1 day'
ORDER BY created_at
`

// Used by the background worker to pick up unprocessed reports.
func (q *Queries) ListPendingReports(ctx context.Context) ([]Report, error) {
	rows, err := q.query(ctx, q.listPendingReportsStmt, listPendingReports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Report{}
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Status,
			&i.ErrorMessage,
			&i.OverallScore,
			&i.CriticalCount,
			&i.RisksJson,
			&i.ExecutiveSummary,
			&i.TopPriorityHtml,
			&i.AccessToken,
			&i.GeneratedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logEmail = `-- name: LogEmail :one

INSERT INTO email_log (session_id, report_id, to_address, subject, template, provider_id, sent_at)
VALUES ($1, $2, $3, $4, $5, $6, now())
RETURNING id, session_id, report_id, to_address, subject, template, provider_id, sent_at, opened_at, error, created_at
`

type LogEmailParams struct {
	SessionID  uuid.NullUUID  `db:"session_id" json:"session_id"`
	ReportID   uuid.NullUUID  `db:"report_id" json:"report_id"`
	ToAddress  string         `db:"to_address" json:"to_address"`
	Subject    string         `db:"subject" json:"subject"`
	Template   string         `db:"template" json:"template"`
	ProviderID sql.NullString `db:"provider_id" json:"provider_id"`
}

// ---------------------------------------------------------------------------
// EMAIL LOG
// ---------------------------------------------------------------------------
func (q *Queries) LogEmail(ctx context.Context, arg LogEmailParams) (EmailLog, error) {
	row := q.queryRow(ctx, q.logEmailStmt, logEmail,
		arg.SessionID,
		arg.ReportID,
		arg.ToAddress,
		arg.Subject,
		arg.Template,
		arg.ProviderID,
	)
	var i EmailLog
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.ReportID,
		&i.ToAddress,
		&i.Subject,
		&i.Template,
		&i.ProviderID,
		&i.SentAt,
		&i.OpenedAt,
		&i.Error,
		&i.CreatedAt,
	)
	return i, err
}

const markEmailOpened = `-- name: MarkEmailOpened :one
UPDATE email_log SET opened_at = now() WHERE provider_id = $1 RETURNING id, session_id, report_id, to_address, subject, template, provider_id, sent_at, opened_at, error, created_at
`

func (q *Queries) MarkEmailOpened(ctx context.Context, providerID sql.NullString) (EmailLog, error) {
	row := q.queryRow(ctx, q.markEmailOpenedStmt, markEmailOpened, providerID)
	var i EmailLog
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.ReportID,
		&i.ToAddress,
		&i.Subject,
		&i.Template,
		&i.ProviderID,
		&i.SentAt,
		&i.OpenedAt,
		&i.Error,
		&i.CreatedAt,
	)
	return i, err
}

const markSessionPaid = `-- name: MarkSessionPaid :one
UPDATE sessions
SET payment_status = 'paid',
    paid_at        = now()
WHERE stripe_payment_intent = $1
RETURNING id, anon_token, email, biz_name, industry, stage, stripe_customer_id, stripe_payment_intent, payment_status, paid_at, utm_source, utm_medium, utm_campaign, referrer, ip_hash, user_agent, created_at, updated_at
`

func (q *Queries) MarkSessionPaid(ctx context.Context, stripePaymentIntent sql.NullString) (Session, error) {
	row := q.queryRow(ctx, q.markSessionPaidStmt, markSessionPaid, stripePaymentIntent)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AnonToken,
		&i.Email,
		&i.BizName,
		&i.Industry,
		&i.Stage,
		&i.StripeCustomerID,
		&i.StripePaymentIntent,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.Referrer,
		&i.IpHash,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markSessionPaymentFailed = `-- name: MarkSessionPaymentFailed :one
UPDATE sessions
SET payment_status = 'failed'
WHERE stripe_payment_intent = $1
RETURNING id, anon_token, email, biz_name, industry, stage, stripe_customer_id, stripe_payment_intent, payment_status, paid_at, utm_source, utm_medium, utm_campaign, referrer, ip_hash, user_agent, created_at, updated_at
`

func (q *Queries) MarkSessionPaymentFailed(ctx context.Context, stripePaymentIntent sql.NullString) (Session, error) {
	row := q.queryRow(ctx, q.markSessionPaymentFailedStmt, markSessionPaymentFailed, stripePaymentIntent)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AnonToken,
		&i.Email,
		&i.BizName,
		&i.Industry,
		&i.Stage,
		&i.StripeCustomerID,
		&i.StripePaymentIntent,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.Referrer,
		&i.IpHash,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markStripeEventFailed = `-- name: MarkStripeEventFailed :one
UPDATE stripe_events
SET processed    = FALSE,
    error        = $2
WHERE stripe_event_id = $1
RETURNING stripe_event_id, type, payload, processed, processed_at, error, received_at
`

type MarkStripeEventFailedParams struct {
	StripeEventID string         `db:"stripe_event_id" json:"stripe_event_id"`
	Error         sql.NullString `db:"error" json:"error"`
}

func (q *Queries) MarkStripeEventFailed(ctx context.Context, arg MarkStripeEventFailedParams) (StripeEvent, error) {
	row := q.queryRow(ctx, q.markStripeEventFailedStmt, markStripeEventFailed, arg.StripeEventID, arg.Error)
	var i StripeEvent
	err := row.Scan(
		&i.StripeEventID,
		&i.Type,
		&i.Payload,
		&i.Processed,
		&i.ProcessedAt,
		&i.Error,
		&i.ReceivedAt,
	)
	return i, err
}

const markStripeEventProcessed = `-- name: MarkStripeEventProcessed :one
UPDATE stripe_events
SET processed    = TRUE,
    processed_at = now()
WHERE stripe_event_id = $1
RETURNING stripe_event_id, type, payload, processed, processed_at, error, received_at
`

func (q *Queries) MarkStripeEventProcessed(ctx context.Context, stripeEventID string) (StripeEvent, error) {
	row := q.queryRow(ctx, q.markStripeEventProcessedStmt, markStripeEventProcessed, stripeEventID)
	var i StripeEvent
	err := row.Scan(
		&i.StripeEventID,
		&i.Type,
		&i.Payload,
		&i.Processed,
		&i.ProcessedAt,
		&i.Error,
		&i.ReceivedAt,
	)
	return i, err
}

const setAIHedge = `-- name: SetAIHedge :one
UPDATE risk_results
SET ai_hedge = $2
WHERE id = $1
RETURNING id, report_id, question_id, rank, risk_name, risk_desc, probability, impact, score, tier, hedge, ai_hedge, section
`

type SetAIHedgeParams struct {
	ID      uuid.UUID      `db:"id" json:"id"`
	AiHedge sql.NullString `db:"ai_hedge" json:"ai_hedge"`
}

func (q *Queries) SetAIHedge(ctx context.Context, arg SetAIHedgeParams) (RiskResult, error) {
	row := q.queryRow(ctx, q.setAIHedgeStmt, setAIHedge, arg.ID, arg.AiHedge)
	var i RiskResult
	err := row.Scan(
		&i.ID,
		&i.ReportID,
		&i.QuestionID,
		&i.Rank,
		&i.RiskName,
		&i.RiskDesc,
		&i.Probability,
		&i.Impact,
		&i.Score,
		&i.Tier,
		&i.Hedge,
		&i.AiHedge,
		&i.Section,
	)
	return i, err
}

const setReportError = `-- name: SetReportError :one
UPDATE reports
SET status        = 'error',
    error_message = $2
WHERE id = $1
RETURNING id, session_id, status, error_message, overall_score, critical_count, risks_json, executive_summary, top_priority_html, access_token, generated_at, created_at, updated_at
`

type SetReportErrorParams struct {
	ID           uuid.UUID      `db:"id" json:"id"`
	ErrorMessage sql.NullString `db:"error_message" json:"error_message"`
}

func (q *Queries) SetReportError(ctx context.Context, arg SetReportErrorParams) (Report, error) {
	row := q.queryRow(ctx, q.setReportErrorStmt, setReportError, arg.ID, arg.ErrorMessage)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Status,
		&i.ErrorMessage,
		&i.OverallScore,
		&i.CriticalCount,
		&i.RisksJson,
		&i.ExecutiveSummary,
		&i.TopPriorityHtml,
		&i.AccessToken,
		&i.GeneratedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setReportProcessing = `-- name: SetReportProcessing :one
UPDATE reports
SET status = 'processing'
WHERE id = $1
RETURNING id, session_id, status, error_message, overall_score, critical_count, risks_json, executive_summary, top_priority_html, access_token, generated_at, created_at, updated_at
`

func (q *Queries) SetReportProcessing(ctx context.Context, id uuid.UUID) (Report, error) {
	row := q.queryRow(ctx, q.setReportProcessingStmt, setReportProcessing, id)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Status,
		&i.ErrorMessage,
		&i.OverallScore,
		&i.CriticalCount,
		&i.RisksJson,
		&i.ExecutiveSummary,
		&i.TopPriorityHtml,
		&i.AccessToken,
		&i.GeneratedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSessionContext = `-- name: UpdateSessionContext :one
UPDATE sessions
SET biz_name = $2,
    industry = $3,
    stage    = $4
WHERE id = $1
RETURNING id, anon_token, email, biz_name, industry, stage, stripe_customer_id, stripe_payment_intent, payment_status, paid_at, utm_source, utm_medium, utm_campaign, referrer, ip_hash, user_agent, created_at, updated_at
`

type UpdateSessionContextParams struct {
	ID       uuid.UUID      `db:"id" json:"id"`
	BizName  sql.NullString `db:"biz_name" json:"biz_name"`
	Industry sql.NullString `db:"industry" json:"industry"`
	Stage    sql.NullString `db:"stage" json:"stage"`
}

func (q *Queries) UpdateSessionContext(ctx context.Context, arg UpdateSessionContextParams) (Session, error) {
	row := q.queryRow(ctx, q.updateSessionContextStmt, updateSessionContext,
		arg.ID,
		arg.BizName,
		arg.Industry,
		arg.Stage,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AnonToken,
		&i.Email,
		&i.BizName,
		&i.Industry,
		&i.Stage,
		&i.StripeCustomerID,
		&i.StripePaymentIntent,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.Referrer,
		&i.IpHash,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAnswer = `-- name: UpsertAnswer :one

INSERT INTO answers (session_id, question_id, answer_text, client_p, client_i)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (session_id, question_id)
DO UPDATE SET
    answer_text = EXCLUDED.answer_text,
    client_p    = EXCLUDED.client_p,
    client_i    = EXCLUDED.client_i,
    updated_at  = now()
RETURNING id, session_id, question_id, answer_text, client_p, client_i, answered_at, updated_at
`

type UpsertAnswerParams struct {
	SessionID  uuid.UUID     `db:"session_id" json:"session_id"`
	QuestionID string        `db:"question_id" json:"question_id"`
	AnswerText string        `db:"answer_text" json:"answer_text"`
	ClientP    sql.NullInt16 `db:"client_p" json:"client_p"`
	ClientI    sql.NullInt16 `db:"client_i" json:"client_i"`
}

// ---------------------------------------------------------------------------
// ANSWERS
// ---------------------------------------------------------------------------
func (q *Queries) UpsertAnswer(ctx context.Context, arg UpsertAnswerParams) (Answer, error) {
	row := q.queryRow(ctx, q.upsertAnswerStmt, upsertAnswer,
		arg.SessionID,
		arg.QuestionID,
		arg.AnswerText,
		arg.ClientP,
		arg.ClientI,
	)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.QuestionID,
		&i.AnswerText,
		&i.ClientP,
		&i.ClientI,
		&i.AnsweredAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertStripeEvent = `-- name: UpsertStripeEvent :one

INSERT INTO stripe_events (stripe_event_id, type, payload)
VALUES ($1, $2, $3)
ON CONFLICT (stripe_event_id) DO NOTHING
RETURNING stripe_event_id, type, payload, processed, processed_at, error, received_at
`

type UpsertStripeEventParams struct {
	StripeEventID string          `db:"stripe_event_id" json:"stripe_event_id"`
	Type          string          `db:"type" json:"type"`
	Payload       json.RawMessage `db:"payload" json:"payload"`
}

// ---------------------------------------------------------------------------
// STRIPE EVENTS
// ---------------------------------------------------------------------------
func (q *Queries) UpsertStripeEvent(ctx context.Context, arg UpsertStripeEventParams) (StripeEvent, error) {
	row := q.queryRow(ctx, q.upsertStripeEventStmt, upsertStripeEvent, arg.StripeEventID, arg.Type, arg.Payload)
	var i StripeEvent
	err := row.Scan(
		&i.StripeEventID,
		&i.Type,
		&i.Payload,
		&i.Processed,
		&i.ProcessedAt,
		&i.Error,
		&i.ReceivedAt,
	)
	return i, err
}
