// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

type PaymentStatus string

const (
	PaymentStatusPending  PaymentStatus = "pending"
	PaymentStatusPaid     PaymentStatus = "paid"
	PaymentStatusFailed   PaymentStatus = "failed"
	PaymentStatusRefunded PaymentStatus = "refunded"
)

func (e *PaymentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentStatus(s)
	case string:
		*e = PaymentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentStatus: %T", src)
	}
	return nil
}

type NullPaymentStatus struct {
	PaymentStatus PaymentStatus `json:"payment_status"`
	Valid         bool          `json:"valid"` // Valid is true if PaymentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentStatus), nil
}

type QuestionType string

const (
	QuestionTypeRadio  QuestionType = "radio"
	QuestionTypeText   QuestionType = "text"
	QuestionTypeSelect QuestionType = "select"
)

func (e *QuestionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = QuestionType(s)
	case string:
		*e = QuestionType(s)
	default:
		return fmt.Errorf("unsupported scan type for QuestionType: %T", src)
	}
	return nil
}

type NullQuestionType struct {
	QuestionType QuestionType `json:"question_type"`
	Valid        bool         `json:"valid"` // Valid is true if QuestionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullQuestionType) Scan(value interface{}) error {
	if value == nil {
		ns.QuestionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.QuestionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullQuestionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.QuestionType), nil
}

type ReportStatus string

const (
	ReportStatusDraft      ReportStatus = "draft"
	ReportStatusProcessing ReportStatus = "processing"
	ReportStatusReady      ReportStatus = "ready"
	ReportStatusError      ReportStatus = "error"
)

func (e *ReportStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ReportStatus(s)
	case string:
		*e = ReportStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ReportStatus: %T", src)
	}
	return nil
}

type NullReportStatus struct {
	ReportStatus ReportStatus `json:"report_status"`
	Valid        bool         `json:"valid"` // Valid is true if ReportStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReportStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ReportStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ReportStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReportStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ReportStatus), nil
}

type RiskTier string

const (
	RiskTierWatch  RiskTier = "watch"
	RiskTierRed    RiskTier = "red"
	RiskTierManage RiskTier = "manage"
	RiskTierIgnore RiskTier = "ignore"
)

func (e *RiskTier) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RiskTier(s)
	case string:
		*e = RiskTier(s)
	default:
		return fmt.Errorf("unsupported scan type for RiskTier: %T", src)
	}
	return nil
}

type NullRiskTier struct {
	RiskTier RiskTier `json:"risk_tier"`
	Valid    bool     `json:"valid"` // Valid is true if RiskTier is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRiskTier) Scan(value interface{}) error {
	if value == nil {
		ns.RiskTier, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RiskTier.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRiskTier) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RiskTier), nil
}

type SectionID string

const (
	SectionIDSnapshot    SectionID = "snapshot"
	SectionIDDependency  SectionID = "dependency"
	SectionIDMarket      SectionID = "market"
	SectionIDOperational SectionID = "operational"
	SectionIDLegal       SectionID = "legal"
	SectionIDBlindspots  SectionID = "blindspots"
)

func (e *SectionID) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SectionID(s)
	case string:
		*e = SectionID(s)
	default:
		return fmt.Errorf("unsupported scan type for SectionID: %T", src)
	}
	return nil
}

type NullSectionID struct {
	SectionID SectionID `json:"section_id"`
	Valid     bool      `json:"valid"` // Valid is true if SectionID is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSectionID) Scan(value interface{}) error {
	if value == nil {
		ns.SectionID, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SectionID.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSectionID) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SectionID), nil
}

type Answer struct {
	ID         uuid.UUID     `db:"id" json:"id"`
	SessionID  uuid.UUID     `db:"session_id" json:"session_id"`
	QuestionID string        `db:"question_id" json:"question_id"`
	AnswerText string        `db:"answer_text" json:"answer_text"`
	ClientP    sql.NullInt16 `db:"client_p" json:"client_p"`
	ClientI    sql.NullInt16 `db:"client_i" json:"client_i"`
	AnsweredAt time.Time     `db:"answered_at" json:"answered_at"`
	UpdatedAt  time.Time     `db:"updated_at" json:"updated_at"`
}

type EmailLog struct {
	ID         uuid.UUID      `db:"id" json:"id"`
	SessionID  uuid.NullUUID  `db:"session_id" json:"session_id"`
	ReportID   uuid.NullUUID  `db:"report_id" json:"report_id"`
	ToAddress  string         `db:"to_address" json:"to_address"`
	Subject    string         `db:"subject" json:"subject"`
	Template   string         `db:"template" json:"template"`
	ProviderID sql.NullString `db:"provider_id" json:"provider_id"`
	SentAt     sql.NullTime   `db:"sent_at" json:"sent_at"`
	OpenedAt   sql.NullTime   `db:"opened_at" json:"opened_at"`
	Error      sql.NullString `db:"error" json:"error"`
	CreatedAt  time.Time      `db:"created_at" json:"created_at"`
}

type PublicRiskStat struct {
	RiskName       string   `db:"risk_name" json:"risk_name"`
	Tier           RiskTier `db:"tier" json:"tier"`
	Section        string   `db:"section" json:"section"`
	Occurrences    int64    `db:"occurrences" json:"occurrences"`
	AvgProbability string   `db:"avg_probability" json:"avg_probability"`
	AvgImpact      string   `db:"avg_impact" json:"avg_impact"`
	AvgScore       string   `db:"avg_score" json:"avg_score"`
}

type QuestionDefinition struct {
	ID              string          `db:"id" json:"id"`
	QuestionVersion int16           `db:"question_version" json:"question_version"`
	SectionID       SectionID       `db:"section_id" json:"section_id"`
	SectionTitle    string          `db:"section_title" json:"section_title"`
	DisplayOrder    int16           `db:"display_order" json:"display_order"`
	Text            string          `db:"text" json:"text"`
	Subtext         sql.NullString  `db:"subtext" json:"subtext"`
	Type            QuestionType    `db:"type" json:"type"`
	Opts            []string        `db:"opts" json:"opts"`
	Placeholder     sql.NullString  `db:"placeholder" json:"placeholder"`
	Required        bool            `db:"required" json:"required"`
	RiskName        string          `db:"risk_name" json:"risk_name"`
	RiskDesc        string          `db:"risk_desc" json:"risk_desc"`
	Hedge           string          `db:"hedge" json:"hedge"`
	ScoringConfig   json.RawMessage `db:"scoring_config" json:"scoring_config"`
	IsScoring       bool            `db:"is_scoring" json:"is_scoring"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
}

type Report struct {
	ID               uuid.UUID             `db:"id" json:"id"`
	SessionID        uuid.UUID             `db:"session_id" json:"session_id"`
	Status           ReportStatus          `db:"status" json:"status"`
	ErrorMessage     sql.NullString        `db:"error_message" json:"error_message"`
	OverallScore     sql.NullInt16         `db:"overall_score" json:"overall_score"`
	CriticalCount    sql.NullInt16         `db:"critical_count" json:"critical_count"`
	RisksJson        pqtype.NullRawMessage `db:"risks_json" json:"risks_json"`
	ExecutiveSummary sql.NullString        `db:"executive_summary" json:"executive_summary"`
	TopPriorityHtml  sql.NullString        `db:"top_priority_html" json:"top_priority_html"`
	AccessToken      string                `db:"access_token" json:"access_token"`
	GeneratedAt      sql.NullTime          `db:"generated_at" json:"generated_at"`
	CreatedAt        time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time             `db:"updated_at" json:"updated_at"`
}

type RiskResult struct {
	ID          uuid.UUID      `db:"id" json:"id"`
	ReportID    uuid.UUID      `db:"report_id" json:"report_id"`
	QuestionID  string         `db:"question_id" json:"question_id"`
	Rank        int16          `db:"rank" json:"rank"`
	RiskName    string         `db:"risk_name" json:"risk_name"`
	RiskDesc    string         `db:"risk_desc" json:"risk_desc"`
	Probability int16          `db:"probability" json:"probability"`
	Impact      int16          `db:"impact" json:"impact"`
	Score       int16          `db:"score" json:"score"`
	Tier        RiskTier       `db:"tier" json:"tier"`
	Hedge       string         `db:"hedge" json:"hedge"`
	AiHedge     sql.NullString `db:"ai_hedge" json:"ai_hedge"`
	Section     string         `db:"section" json:"section"`
}

type Session struct {
	ID                  uuid.UUID      `db:"id" json:"id"`
	AnonToken           string         `db:"anon_token" json:"anon_token"`
	Email               sql.NullString `db:"email" json:"email"`
	BizName             sql.NullString `db:"biz_name" json:"biz_name"`
	Industry            sql.NullString `db:"industry" json:"industry"`
	Stage               sql.NullString `db:"stage" json:"stage"`
	StripeCustomerID    sql.NullString `db:"stripe_customer_id" json:"stripe_customer_id"`
	StripePaymentIntent sql.NullString `db:"stripe_payment_intent" json:"stripe_payment_intent"`
	PaymentStatus       PaymentStatus  `db:"payment_status" json:"payment_status"`
	PaidAt              sql.NullTime   `db:"paid_at" json:"paid_at"`
	UtmSource           sql.NullString `db:"utm_source" json:"utm_source"`
	UtmMedium           sql.NullString `db:"utm_medium" json:"utm_medium"`
	UtmCampaign         sql.NullString `db:"utm_campaign" json:"utm_campaign"`
	Referrer            sql.NullString `db:"referrer" json:"referrer"`
	IpHash              sql.NullString `db:"ip_hash" json:"ip_hash"`
	UserAgent           sql.NullString `db:"user_agent" json:"user_agent"`
	CreatedAt           time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt           time.Time      `db:"updated_at" json:"updated_at"`
}

type StripeEvent struct {
	StripeEventID string          `db:"stripe_event_id" json:"stripe_event_id"`
	Type          string          `db:"type" json:"type"`
	Payload       json.RawMessage `db:"payload" json:"payload"`
	Processed     bool            `db:"processed" json:"processed"`
	ProcessedAt   sql.NullTime    `db:"processed_at" json:"processed_at"`
	Error         sql.NullString  `db:"error" json:"error"`
	ReceivedAt    time.Time       `db:"received_at" json:"received_at"`
}
